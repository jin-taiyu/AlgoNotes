### 2024年3月21日

问题描述：小羊肖恩是一只非常聪明的绵羊，在牧场里与其他绵羊一起生活。有一天，它在草地上漫步时，发现了一些数字。它猜想这些数字可能在某些方面有用，于是把它们带回了牧场，并开始研究它们。

具体来说，小羊有一个长度为 $n$ 的数组，第 $i$ 个数字的值为 $a_i$ 。小羊肖恩心中想了两个数 $L$ 和 $R$ ，它想知道有多少对下标对 $(i, j)$​ 满足以下条件：
$$
\begin{cases}
1 \le i \le j \le n \\
L \le a_i + a_j \le R
\end{cases}
$$


对于这道题，一开始没解出来，看了题解之后才反应过来。

要理解这道题，需要理解这几个问题：

1. 有关==排序==

   对于排序（其实一开始就想到了，一开始的思路是**排序+双指针**），我们需要理解，对于序列 $a_1, a_2, a_3, ..., a_n$ 在经过排序之后 $a_1', a_2', a_3', ..., a_n'$ ，原有的 $i$ 和 $j$​ 序列已经发生了变化，那么满足条件 $\begin{cases}
   1 \le i \le j \le n \\
   L \le a_i + a_j \le R
   \end{cases}$​ 的序列数量还一样吗？

   我们可以看到，对于限制条件 $1 \le i \le j \le n$ ，这其实影响了元素对 $<a_i, a_j>$ 的有序性，假如没有这个限制条件，那么我们找到的就是有序对，其数量是无序对的两倍。而有序对可以理解为是整个序列中所有满足条件 $L \le a_i + a_j \le R$ 的情况，无论序列顺序如何变化，满足条件的“对”的数量都不会变，那么其一半 $满足条件的无序对数量 = \frac{满足条件的有序对数量}{2}$ ，自然也不会变化。

2. 有关查找

   接下来的任务就是在有序序列中，找到满足条件的“对”。我们自然可以直接开始遍历，但这样的复杂度就为 $O(n \times n) = O(n^2)$ 了，这无异于暴力方法。

   想到搜索，我们可以想到一个 $O(\log{n})$ 的方法：二分查找。考虑使用函数

   ```c++
   //查找[first, last)区域中第一个大于 val 的元素。
   ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T& val);
   ```

   ```c++
   //在 [first, last) 区域内查找不小于 val 的元素
   ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T& val);
   ```

   对于函数 `upper_bound()` 和 `lower_bound()` ，我们可以结合起来使用。 