### 2024年3月30日

今天写算法设计与分析课程作业，在此记录一些笔记和心得。

1. 分椰子

   **问题描述**：水手分椰子。n 个水手来到一个岛上,摘了一堆椰子后,因为疲劳都睡着了。一段时间后,第一个水手醒来,悄悄地将椰子等分成 n 份,多出 m 个椰子,便给了旁边的猴子， 自己藏起一份，再将剩下的椰子重新合在一起，继续睡觉。不久，第二名水手醒来，同样将椰子等分成n 份，恰好也多出 m 个给了猴子，自己也藏起一份，再将剩下的椰子重新合在一起。以后每个水手都如此等分并都藏起一份，也恰好都把多出的 m 个椰子给了猴子。第二天，n 个水手都醒来了，发现椰子少了许多，彼此心照不宣，便把剩下的椰子分成 n份，恰好又多出 m 个给了猴子。请问:水手当初最少摘了多少个椰子?

   

   **解题思路**：这个问题可以用递推的方法来解决。

   $n$ 个人分椰子，每个人单独分成 $n$ 份并去掉 $m$ 个，最后全部的人在一起将椰子分成 $n$ 份并去掉 $m$ 个。

   概括为：将椰子每次分成 $n$ 份再去掉 $m$ 个，一共要进行这样的操作 $n + 1$ 次。

   假设第 $i$ 次醒来的那个人自己留的那一份为 $y_i$ ，那么有
   $$
   \begin{equation}
   (n - 1) \cdot y_{i - 1} = n \cdot y_{i} + m \\
   \Rightarrow y_{i - 1} = \frac{n \cdot y_{i} + m}{n - 1}
   \end{equation}
   $$
    我们知道，椰子肯定是被整分的，因此我们如果要求最小的初始椰子数，我们可以假设最后一次划分每个水手只得到了 $1$ 个椰子，即
   $$
   n \cdot 1 + m
   $$
   我们可以从 $y_{n + 1} = 1$ 向前递推，最终推导到 $y_1$ ，水手当初最少摘了 $n \cdot y_1 + m$ 个椰子。

   ```c++
   #include <iostream>
   using namespace std;
   const int N = 1005;
   int dp[N];
   int n, m;
   
   int main(int argc, char** argv) {
       memset(dp, 0, sizeof(dp));
       cin >> n >> m;
       dp[n + 1] = 1;
       for (int i = n; i >= 1; i--) {
           dp[i - 1] = (n * dp[i] + m) / (n - 1);
       }
       cout << n * dp[1] + m << endl;
       return 0;
   }
   ```

2. 排队

   **问题描述**：$8$ 个高矮不同的人需要排成两队，每队 $4$ 个人。其中，每排都是从低到高排列，且第二排的第 $i$ 个人比第一排中第 $i$​ 个人高，有多少种排队方式。

   这道题应该是**卡特兰数列**的延伸问题。

   其实对于卡特兰数列，在上学期数据结构课程中，我看到的一本参考书籍（The Art of Computer Programming, Donald E. Knuth）中一道课后习题对于“栈可以得到的 $n$ 个元素的排列数”就比较类似，只是当时并不知道这是卡特兰数列问题。回忆一下当时的解法：

   用 $S$ 表示入栈，用 $X$ 表示出栈，能有以下性质

   - 在一个容许的序列中，从左向右数， $X$ 的个数从不会超过 $S$ 的个数

   - 两个不同的容许的序列一定产生不同的结果

     因为如果这两个序列到某一位之前之前一直相同，则该位一个为 $S$ ，而另一个为 $X$ ，则后一个序列此时输出一个符号，而前一个序列不可能也输出这个符号，因为由 $S$ 刚插入的符号必须先输出。

   而对于栈可以得到的 $n$ 个元素的排列数，这个问题与许多有趣的问题等价，如二叉树的枚举计数，向公式中插入括号的方法数，以及把一个多边形划分成三角形的方法数。早在 $1759$ 年，这类问题就出现在欧拉和赛格纳的笔记中。

   下面的精彩解法使用了“反射原理”：

   显然，包含 $n$ 个 $S$ 和 $n$ 个$X$ 的序列共有 $\begin{pmatrix} 2n \\ n \end{pmatrix}$ 个，只需要计算**不容许**的序列的数目（在这种序列中， $S$ 和 $X$ 的个数正确，但并不满足另一个条件）。在任意不容许的序列中，确定 $X$ 的个数首次超过 $S$ 的位置，然后，在从最左端到这个 $X$ （包含 $X$ ）的部分序列中，把每个 $X$ 用 $S$ 替换，结果是一个具有 $(n + 1)$ 个$S$ 和 $(n - 1)$ 个 $X$ 的序列。反过来，对于每个这种类型的序列，都可以逆转这一过程，找出导致它的不容许序列。例如，序列 $XXSXSS\underline{S}XXSSS$ 一定源于 $SSXSXX\underline{X}XXSSS$ ，这种对应表明，不容许的序列数为 $\begin{pmatrix} 2n \\ n - 1 \end{pmatrix}$ 。因此 $a_{n} = \begin{pmatrix} 2n \\ n \end{pmatrix} - \begin{pmatrix} 2n \\ n - 1 \end{pmatrix}$​ 。

   

   回到本题中，这道题仍然可以用卡特兰数列来解决。我们可以采用这样的思路：

   首先，我们可以假设所有的 $2n = 8$ 个人全都按照高矮顺序排成一排，由于两个队伍 $n = 4$ 都必须是从低到高排列，所以我们可以模拟出这 $2n = 8$ 个人站到两个 $n = 4$ 的队伍中，一定是按照原来的顺序一个一个站进去的，那么第一个条件（每排都是从低到高排列）就解决了。

   我们再假设站到第一个队伍里是 $0$ ，站到第二个队伍里是 $1$ ，那么整个排队的过程就可以写为        $01001011$ 这样的长度为 $2n = 8$ 的序列，我们对该问题的研究就转换到这个序列上，怎样排列可以使得第二排的第 $i$ 个人比第一排中第 $i$ 个人高，我们对该序列可以定两个约束：

   -  $0$ 和 $1$ 的个数都只能为 $n = 4$ ，因为两个队伍都只有 $4$ 个人。
   -  在任意一个位置，从最左端到这个位置的序列里 $1$ 的个数不能超过 $0$​ 的个数。
      - 为什么呢？这是因为每个在第二排的人都必须有一个在第一排的人与之对应，以满足“第二排的第i个人比第一排中第i个人高”的规则。而这个条件确保了在任意时刻，第二排（代表为 $1$ ）的人数不会超过第一排（代表为 $0$ ）的人数，从而确保了每个第二排的人（ $1$ ）都有一个对应比他矮的第一排的人（ $0$ ）。

   那么这个问题就被建模为卡特兰数列，其答案与上面的公式对应，$a_{n} = \begin{pmatrix} 2n \\ n \end{pmatrix} - \begin{pmatrix} 2n \\ n - 1 \end{pmatrix} = \begin{pmatrix} 8 \\ 4 \end{pmatrix} - \begin{pmatrix} 8 \\ 3 \end{pmatrix} = 14$ 。

   

   当然，组合数的计算并不是特别适用于 C/C++ ，我们可以采用递推方式来计算：

   ```c++
   #include <iostream>
   #define ll long long
   using namespace std;
   ll dp[25];
   int n;
   
   int main() {
     dp[0] = 1;
     cin >> n;
     for (int i = 1; i <= n; i++) dp[i] = dp[i - 1] * (4 * i - 2) / (i + 1);
     cout << dp[n] << endl;
     return 0;
   }
   ```

   

   *关于卡特兰数列的常见公式*：
   $$
   H_n = \begin{cases}
       \sum_{i=1}^{n} H_{i-1} H_{n-i} & n \geq 2, n \in \mathbf{N_{+}}\\
       1 & n = 0, 1
   \end{cases}
   $$

   $$
   H_n = \frac{\binom{2n}{n}}{n+1}(n \geq 2, n \in \mathbf{N_{+}})
   $$

   $$
   H_n = \frac{H_{n-1} (4n-2)}{n+1}
   $$

   $$
   H_n = \binom{2n}{n} - \binom{2n}{n-1}
   $$

   